## Task 3

この問題ではバージョン管理システムを模したデータ構造について扱います。

このバージョン管理システムでは、1 つのプロジェクトを管理します。システムではプロジェクトの履歴に「バージョン」が付与され、またシステムは変更を表す「コミット」を保持します。
はじめ、プロジェクトのバージョンは 0 です。コミットには1から順に整数の番号がついており、i 番目のコミット後にできたプロジェクトのバージョンは i となります。この問題では N 個のコミットがある場合を考えます。

コミットには 2 種類あり、あるバージョンのプロジェクトを更新する「アップデート」と、2 つのバージョンのプロジェクトの内容を統合する「マージ」からなります。
アップデートでは元となったバージョンの情報が、マージでは 2 つのバージョンの情報が与えられます。

このバージョン管理システムについて、どの時点からバグが発生していたかを調べる機能を追加しようとしています。
具体的には、バグがないと確認されたバージョンのリストと、バグがあると確認されたバージョンのリストが与えられるので、バグが初めて混入した可能性のあるバージョンがいくつあるか求めて下さい。
ただし、あるちょうど 1 つのバージョンで初めてバグが発生し、それ以降のバージョンにおいて新たなバグが発生したりバグが修正されたりしていないものとします。

## 入出力

### 入力
プログラムに、以下のフォーマットの標準入力が与えられます。

N A B  
commit<sub>1</sub>  
:  
commit<sub>N</sub>  
p<sub>1</sub> ... p<sub>A</sub>  
q<sub>1</sub> ... q<sub>B</sub>

はじめの 1 行には、コミットの数を表す N、バグがないと確認されたバージョンの数 A、バグがあると確認されたバージョンの数 B が与えられます。(1 ≤ N ≤ 1000, 1 ≤ A, B ≤ N)  
続く N 行にはコミットの情報が与えられます。それぞれのコミットは以下のフォーマットで与えられます。

- アップデートの場合

UPDATE v

ここで v は元となったバージョンを表します。

- マージの場合

MERGE v<sub>1</sub> v<sub>2</sub>

ここで v<sub>1</sub>, v<sub>2</sub> は元となった 2 つのバージョンを表します。(v<sub>1</sub> ≠ v<sub>2</sub>)

アップデートとマージの両方の場合において、元となったバージョンはそのコミットによって作られるバージョンより小さいことが保証されます。

続く 2 行にはバグがないと確認されたバージョンのリスト p と、バグがあると確認されたバージョンのリスト q が与えられます。

入力はどこか 1 つのコミットによってバグが発生している状態を表します。
したがって、どのコミットでもバグが発生したと考えられなかったり、同じコミットが p と q の両方に現れると言ったことはありません。

### 出力
バグが混入した可能性のあるコミットがいくつあるかを標準出力に 1 行で出力してください。

## 入出力例
### 例 1
標準入力
```
3 1 1
UPDATE 0
UPDATE 1
MERGE 1 2
1
3
```
標準出力
```
2
```
コミット 2 かコミット 3 によってバグが発生しました。
コミット 2 によってバグが発生した場合、バージョン 0, 1 ではバグがなく、バージョン 2, 3 ではバグがあります。
コミット 3 によってバグが発生した場合、バージョン 0, 1, 2 ではバグがなく、バージョン 3 ではバグがあります。

### 例 2
標準入力
```
12 3 3
UPDATE 0
UPDATE 1
UPDATE 2
UPDATE 3
MERGE 4 0
MERGE 2 1
MERGE 5 6
UPDATE 7
MERGE 8 4
UPDATE 9
MERGE 10 2
UPDATE 11
3 2 6
11 9 5
```
標準出力
```
2
```
コミット 4 かコミット 5 によってバグが発生しました。
コミット 4 によってバグが発生した場合、バージョン 0, 1, 2, 3, 6 ではバグがなく、バージョン 4, 5, 7, 8, 9, 10, 11, 12 ではバグがあります。
コミット 5 によってバグが発生した場合、バージョン 0, 1, 2, 3, 4, 6 ではバグがなく、バージョン 5, 7, 8, 9, 10, 11, 12 ではバグがあります。
